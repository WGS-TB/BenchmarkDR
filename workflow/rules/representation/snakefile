import glob
import getpass
from pathlib import Path
import os

os.chdir("/rds/general/user/ns1920/home/project_2/workflow/rules/representation")
configfile: "config.yml"


###########################
# Configure Data Path     #
# (do in config in future)#
###########################


user = getpass.getuser()
path_data = str(Path("/rds/general/user/" + user +
                     "/projects/bacterial_datasets/live/pipeline_data")) + "/"

# specifiy bacteria (will later be done within overall config)
BACTERIA = ["test_bacterium"]

#######################################################################
# Get Strain and Reference IDs from Folder (also other script later?) #
# and function to replace expand                                      #
#######################################################################

STRAINS_IDS = {}
REFERENCE_IDS = {}

for bacterium in BACTERIA:

    # fastq files: reduce file names of paired-end reads to strain ID
    file_list_fastq = glob.glob(path_data + bacterium + "/data/*.fastq")
    if file_list_fastq:

        file_list_fastq = [Path(f).stem for f in file_list_fastq]
        file_list_fastq = list(set([f.split("_")[0] for f in file_list_fastq]))
        STRAINS_IDS[bacterium] = file_list_fastq

    # fasta files
    file_list_fa = glob.glob(path_data + bacterium + "/data/*.fa")
    if file_list_fa:

        if STRAINS_IDS.get(bacterium):
            STRAINS_IDS[bacterium] = STRAINS_IDS[bacterium] + \
                [Path(f).stem for f in file_list_fa]
        else:
            STRAINS_IDS[bacterium] = [Path(f).stem for f in file_list_fa]

    # reference genomes
    file_reference_fna = glob.glob(path_data + bacterium + "/reference/*.fna")
    if file_reference_fna:
        REFERENCE_IDS[bacterium] = Path(file_reference_fna[0]).stem

    else:
        file_reference_fa = glob.glob(path_data + bacterium + "/reference/*.fna")
        if file_reference_fa:
            REFERENCE_IDS[bacterium] = Path(file_reference_fa[0]).stem

## Function to combine all single files for bacterium to combine in matrix

def get_bacteria_strains(bacterium, representation):
    files = list()

    if representation == "kmer":
        path = path_data + "{bacterium}/representation/kmer/{strain_id}.txt"

    if representation == "snps":
        path = path_data + "{bacterium}/representation/snps/{strain_id}.snps"

    for bacterium, strains in STRAINS_IDS.items():
        for strain_id in strains:
            files.append(path.format(bacterium=bacterium, strain_id=strain_id))
    return files

# Function to only test for one bacterium
# def get_bacteria_strains(bacterium):
#     files = list()
#     path = path_data + "{bacterium}/representation/snps/{strain_id}.snps"

#     for strain_id in STRAINS_IDS[bacterium]:
#         files.append(path.format(bacterium=bacterium, strain_id=strain_id))
#     return files

#############################
#                           #
# Rules for Representations #
#                           #
#############################

#rule all:
#    input: get_bacteria_strains("test_bacterium")

rule all:
    input:
        expand(
            path_data + "{bacterium}/representation/snps/0_matrix.csv", bacterium=BACTERIA)


###########
###########
## UTILS ##
###########
###########

###################
# Alignment (BAM) #
###################

rule fastq_to_bam:
    input:
        read_1 = path_data + "{bacterium}/data/{strain_id}_1.fastq",
        read_2 = path_data + "{bacterium}/data/{strain_id}_2.fastq",
        reference = lambda wildcards: "{path_data}{bacterium}/reference/{reference_id}.fna".format(path_data=path_data, bacterium=wildcards.bacterium, reference_id = REFERENCE_IDS[wildcards.bacterium])

    output:
        temp(path_data + "{bacterium}/representation/alignment/{strain_id}.bam")

    params:
        reference_folder = lambda wildcards: "{path_data}{bacterium}/reference/index".format(path_data=path_data, bacterium=wildcards.bacterium),
        reference = lambda wildcards: "{path_data}{bacterium}/reference/index/{bacterium}".format(path_data=path_data, bacterium=wildcards.bacterium)

    conda:
        "../../envs/representation/snps.yml"

    shell:
        '''
         mkdir -p {params.reference_folder}
         bwa index -p {params.reference} {input.reference}
         bwa mem {params.reference} {input.read_1} {input.read_2} | samtools view -b -q 1 - | samtools sort - -o {output}
        '''


###########
###########
## KMERs ##
###########
###########

#########
# FASTQ #
#########

rule kmer_count_fastq:
    input:
        read_1 = path_data + "{bacterium}/data/{strain_id}_1.fastq",
        read_2 = path_data + "{bacterium}/data/{strain_id}_2.fastq"

    output:
        temp(path_data +
             "{bacterium}/representation/kmer/{strain_id}.intermediate")

    params:
        length = config["kmer_count"]["kmer_length"],
        memory = config["kmer_count"]["memory"],
        min = config["kmer_count"]["min_count"],
        max = config["kmer_count"]["max_count"],
        canonical_form = config["kmer_count"]["canonical_form"],
        tmp_folder = path_data + "{bacterium}/representation/kmer/"

    conda:
        "../../envs/representation/kmer.yml"

    shell:
        """
        file_write="{input.read_1}\n{input.read_2}" 
        echo "$file_write" > {params.tmp_folder}/input_list.lst

        if [ '{params.canonical_form}' = 'True' ]
           then
               kmc -k{params.length} -m{params.memory} -ci{params.min} -cx{params.max} @{params.tmp_folder}/input_list.lst {output} {params.tmp_folder}
               touch {output}
           else
               kmc -b -k{params.length} -m{params.memory} -ci{params.min} -cx{params.max} @{params.tmp_folder}/input_list.lst {output} {params.tmp_folder}
               touch {output}
        fi
        """


#########
# FASTA #
#########

rule kmer_count_fasta:
    input:
        path_data + "{bacterium}/data/{strain_id}.fa"

    output:
        temp(path_data +
             "{bacterium}/representation/kmer/{strain_id}.intermediate")

    params:
        length = config["kmer_count"]["kmer_length"],
        memory = config["kmer_count"]["memory"],
        min = config["kmer_count"]["min_count"],
        max = config["kmer_count"]["max_count"],
        canonical_form = config["kmer_count"]["canonical_form"],
        tmp_folder = path_data + "{bacterium}/representation/kmer/"

    conda:
        "../../envs/representation/kmer.yml"

    shell:
        """
        if [ '{params.canonical_form}' = 'True' ]
           then
               kmc -k{params.length} -m{params.memory} -ci{params.min} -cx{params.max} -fm {input} {output} {params.tmp_folder}
               touch {output}
           else
               kmc -b -k{params.length} -m{params.memory} -ci{params.min} -cx{params.max} -fm {input} {output} {params.tmp_folder}
               touch {output}
        fi
        """


##########
# TO TXT #
##########

rule kmer_count_to_txt:
    input:
        path_data + "{bacterium}/representation/kmer/{strain_id}.intermediate"

    output:
        path_data + "{bacterium}/representation/kmer/{strain_id}.txt"

    conda:
        "../../envs/representation/kmer.yml"

    shell:
        "kmc_dump -s {input} {output}"
        # -s: sorted output


##########################
# TXT TO COMBINED MATRIX #
##########################

rule txt_to_matrix:
    input:
        lambda wildcards: get_bacteria_strains(
            '{bacterium}'.format(bacterium=wildcards.bacterium), "kmer")

    output:
        path_data + "{bacterium}/representation/kmer/0_matrix.csv"

    conda:
        "../../envs/representation/pandas.yml"

    script:
        "../../scripts/representation/txt_to_matrix.py"


##########
##########
## SNPs ##
##########
##########

###################################################
# FASTQ to PILEUP (Alignment, SAM -> BAM, PILEUP) #
###################################################

rule fastq_to_pileup:
    input:
        bam = path_data + "{bacterium}/representation/alignment/{strain_id}.bam",
        reference = lambda wildcards: "{path_data}{bacterium}/reference/{reference_id}.fna".format(path_data=path_data, bacterium=wildcards.bacterium, reference_id = REFERENCE_IDS[wildcards.bacterium])

    output:
        temp(path_data + "{bacterium}/representation/snps/{strain_id}.pileup")

    conda:
        "../../envs/representation/snps.yml"

    shell:
        '''
        samtools mpileup -f {input.reference} {input.bam} > {output}
        '''


##################
# PILEUP to SNPs #
##################

rule pileup_to_SNP:
    input:
        path_data + "{bacterium}/representation/snps/{strain_id}.pileup"

    output:
        path_data + "{bacterium}/representation/snps/{strain_id}.snps"

    conda:
        "../../envs/representation/snps.yml"

    shell:
        '''
        varscan mpileup2snp {input} > {output}
        '''

##################
# SNPs to MATRIX #
##################

rule snps_to_matrix:
    input:
        lambda wildcards: get_bacteria_strains(
            '{bacterium}'.format(bacterium=wildcards.bacterium), "snps")

    output:
        path_data + "{bacterium}/representation/snps/0_matrix.csv"

    conda:
        "../../envs/representation/pandas.yml"

    script:
        "../../scripts/representation/snps_to_matrix.py"


###########################
###########################
## Gene Presence Absence ##
###########################
###########################

# rule fastq_to_gene_presence_absence:
#     input:
#         read_1 = path_data + "{bacterium}/data/{strain_id}_1.fastq",
#         read_2 = path_data + "{bacterium}/data/{strain_id}_2.fastq",
#         reference = lambda wildcards: "{path_data}{bacterium}/reference/{reference_id}.fna".format(path_data=path_data, bacterium=wildcards.bacterium, reference_id = REFERENCE_IDS[wildcards.bacterium])

#     output:
#         path_data + "{bacterium}/representation/gene_presence_absence/{strain_id}"

#     params:
#         reference = lambda wildcards: "{path_data}{bacterium}/reference/index/{bacterium}".format(path_data=path_data, bacterium=wildcards.bacterium)

#     conda:
#         "../../envs/representation/gene_presence_absence.yml"

#     shell:
#         '''
         
#         '''